# -*- coding: utf-8 -*-
"""Home Credit Default Risk_DataPrep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zK0ooRAotqJlSSsUlUOEyD9ifKGvS0UZ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import gc

import warnings
warnings.filterwarnings('ignore')
from sklearn.preprocessing import LabelEncoder

! gdown 1E9saoE5S637izLNz-oONPKpUEolD--iB

! gdown 17O-10vq80ufw9S6qCyAC2Tqvf134-iPV

! gdown 1xqc9H6S1v8MvnZSp_Q9AJ-eMCigKOdW7

! gdown 1CnwpyDtYOPfkAb6p6THXTOx8U9VrJit2

! gdown 1Gqze15BQlp-hxvX6wYK5J7Yjaepv503S

! gdown 1Gs76Oi6DjWgTvCQ92Yv_IlqrVsEJMLJh

! gdown 1Xgu9bqigQYOvROPl2Fku6iPvG-zNxQgP

! gdown 1fkF1-1KDoVcQcbJzzRvYZb9AjyHqqgrJ

! gdown 1FiSbRKMwXnYzpV4LnJ-XKxdknAU1Y9j7

def reduce_mem_usage(df, verbose=True):
    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
    start_mem = df.memory_usage(deep=True).sum() / 1024 ** 2 # just added 
    for col in df.columns:
        col_type = df[col].dtypes
        if col_type in numerics:
            c_min = df[col].min()
            c_max = df[col].max()
            if str(col_type)[:3] == 'int':
                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                    df[col] = df[col].astype(np.int8)
                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                    df[col] = df[col].astype(np.int16)
                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                    df[col] = df[col].astype(np.int32)
                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                    df[col] = df[col].astype(np.int64)  
            else:
                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
                    df[col] = df[col].astype(np.float16)
                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                    df[col] = df[col].astype(np.float32)
                else:
                    df[col] = df[col].astype(np.float64)    
    end_mem = df.memory_usage(deep=True).sum() / 1024 ** 2
    percent = 100 * (start_mem - end_mem) / start_mem
    print('Mem. usage decreased from {:5.2f} Mb to {:5.2f} Mb ({:.1f}% reduction)'.format(start_mem, end_mem, percent))
    return df

train=pd.read_csv('application_train.csv')
test=pd.read_csv('application_test.csv')
POS_CASH_balance=pd.read_csv('POS_CASH_balance.csv')
bureau=pd.read_csv('bureau.csv')
bureau_balance=pd.read_csv('bureau_balance.csv')
credit_card_balance=pd.read_csv('credit_card_balance.csv')
installments_payments=pd.read_csv('installments_payments.csv')
previous_application=pd.read_csv('previous_application.csv')

train=reduce_mem_usage(train)
test=reduce_mem_usage(test)
POS_CASH_balance=reduce_mem_usage(POS_CASH_balance)
bureau=reduce_mem_usage(bureau)
bureau_balance=reduce_mem_usage(bureau_balance)
credit_card_balance=reduce_mem_usage(credit_card_balance)
installments_payments=reduce_mem_usage(installments_payments)
previous_application=reduce_mem_usage(previous_application)

"""**Bureau features**"""

tmp = bureau_balance.loc[bureau_balance['STATUS'] == 'C', ['SK_ID_BUREAU', 'MONTHS_BALANCE']].groupby('SK_ID_BUREAU').last()
tmp.columns = ['When_cb_closed']
tmp=tmp.reset_index()
bureau=bureau.merge(tmp, on='SK_ID_BUREAU', how='left')
del tmp
gc.collect()

last_month_closed=bureau.groupby('SK_ID_CURR').agg({'When_cb_closed':['min','max','mean']})
last_month_closed.columns = last_month_closed.columns.map('_'.join)
last_month_closed=last_month_closed.reset_index()

temp=bureau_balance.groupby(['SK_ID_BUREAU'])['STATUS'].value_counts().to_frame().rename({'STATUS':'no_month'}, axis=1).reset_index()
temp=temp[~temp['STATUS'].isin(['X','C','0'])]

temp=temp.pivot(index='SK_ID_BUREAU', columns='STATUS', values='no_month')
temp=temp.reset_index()
temp=temp.fillna(0)

bureau=bureau.merge(temp, on='SK_ID_BUREAU', how='left')

del temp
gc.collect()

L=['1','2','3','4','5']
for col in L:
  bureau[col]=bureau[col].fillna(0)

bureau['cb_DPD_1_5_tot']=bureau[L].sum(axis=1)

"""Replace\remove some outliers in bureau"""

bureau.loc[bureau['AMT_ANNUITY'] > .8e8, 'AMT_ANNUITY'] = np.nan
bureau.loc[bureau['AMT_CREDIT_SUM'] > 3e8, 'AMT_CREDIT_SUM'] = np.nan
bureau.loc[bureau['AMT_CREDIT_SUM_DEBT'] > 1e8, 'AMT_CREDIT_SUM_DEBT'] = np.nan
bureau.loc[bureau['AMT_CREDIT_MAX_OVERDUE'] > .8e8, 'AMT_CREDIT_MAX_OVERDUE'] = np.nan
bureau.loc[bureau['DAYS_ENDDATE_FACT'] < -10000, 'DAYS_ENDDATE_FACT'] = np.nan
bureau.loc[(bureau['DAYS_CREDIT_UPDATE'] > 0) | (bureau['DAYS_CREDIT_UPDATE'] < -40000), 'DAYS_CREDIT_UPDATE'] = np.nan
bureau.loc[bureau['DAYS_CREDIT_ENDDATE'] < -10000, 'DAYS_CREDIT_ENDDATE'] = np.nan
    
bureau.drop(bureau[bureau['DAYS_ENDDATE_FACT'] < bureau['DAYS_CREDIT']].index, inplace = True)

no_cb_past_loans=bureau.groupby('SK_ID_CURR')['DAYS_CREDIT'].count().to_frame().rename({'DAYS_CREDIT':'cb_no_prev_loans'}, axis=1).reset_index()

#bureau['DAYS_CREDIT_ENDDATE']=bureau['DAYS_CREDIT_ENDDATE'].fillna(0)
#bureau['DAYS_ENDDATE_FACT']=bureau['DAYS_ENDDATE_FACT'].fillna(0)

"""Getting customer Credit Age for CB"""

bureau_credit_age=bureau.groupby('SK_ID_CURR').agg({'DAYS_CREDIT':['max','min','mean','sum']})

bureau_credit_age.columns = bureau_credit_age.columns.map('_'.join)
bureau_credit_age=bureau_credit_age.reset_index()

bureau_credit_update=bureau.groupby('SK_ID_CURR').agg({'DAYS_CREDIT_UPDATE':['max','min','mean','sum']})

bureau_credit_update.columns = bureau_credit_update.columns.map('_'.join)
bureau_credit_update=bureau_credit_update.reset_index()

#bureau=bureau[bureau['DAYS_CREDIT_UPDATE']>-2555]

credit_status=bureau.groupby(['SK_ID_CURR','CREDIT_ACTIVE'])['CREDIT_ACTIVE'].count()
credit_status=credit_status.to_frame().rename({'CREDIT_ACTIVE':'Credit_Status'}, axis=1).reset_index()
credit_status=credit_status.pivot(index='SK_ID_CURR', columns='CREDIT_ACTIVE', values='Credit_Status')
credit_status=credit_status.fillna(0).reset_index()
#credit_status['Total_bureau_credits']=credit_status[['Active','Bad debt','Closed','Sold']].sum(axis=1)
L=credit_status.columns[1:]

for col in L:
 credit_status['cb_'+col]=credit_status[col]
 credit_status=credit_status.drop([col], axis=1)
#credit_status.drop('Total_bureau_credits', axis=1, inplace=True)

debt_currency=bureau.groupby(['SK_ID_CURR','CREDIT_CURRENCY'])['AMT_CREDIT_SUM_DEBT'].sum()
debt_currency=debt_currency.to_frame().rename({'AMT_CREDIT_SUM_DEBT':'Currency_debt'}, axis=1).reset_index()
debt_currency=debt_currency.pivot(index='SK_ID_CURR', columns='CREDIT_CURRENCY', values='Currency_debt')
debt_currency=debt_currency.fillna(0).reset_index()
debt_currency=debt_currency.rename({'currency 1':'currency1_debt','currency 2':'currency2_debt','currency 3':'currency3_debt',
                                                     'currency 4':'currency4_debt'}, axis=1)

bureau['Delayed_Credit_End']=bureau['DAYS_ENDDATE_FACT']-bureau['DAYS_CREDIT_ENDDATE']

temp1=bureau[bureau['Delayed_Credit_End']>0].groupby('SK_ID_CURR')['SK_ID_BUREAU'].count().to_frame().reset_index().rename({'SK_ID_BUREAU':'no_delayed_credits'},axis=1)
temp2=bureau.groupby('SK_ID_CURR')['SK_ID_BUREAU'].count().to_frame().reset_index().rename({'SK_ID_BUREAU':'no_credits'},axis=1)
delayed_credits=temp2.merge(temp1, on='SK_ID_CURR', how='left').fillna(0)
delayed_credits['ratio_delayed_credits_cb']=delayed_credits['no_delayed_credits']/delayed_credits['no_credits']

del temp1, temp2
gc.collect()

bureau['cb_credit_term']=bureau['DAYS_CREDIT_ENDDATE']-bureau['DAYS_CREDIT']

bureau_days_stat=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR').agg({'Delayed_Credit_End':['max','min', 'mean','median'],'cb_credit_term':['max','min', 'mean','median'] })

bureau_days_stat.columns = bureau_days_stat.columns.map('_'.join)
bureau_days_stat=bureau_days_stat.reset_index()

DPD_cb_less_60=bureau[(bureau['CREDIT_DAY_OVERDUE']>=30)&(bureau['CREDIT_DAY_OVERDUE']<60)].groupby('SK_ID_CURR')['CREDIT_DAY_OVERDUE'].count().to_frame().rename({'CREDIT_DAY_OVERDUE':'cb_no_CREDIT_DAY_OVERDUE_30_60'}, axis=1).reset_index()
DPD_cb_less_90=bureau[(bureau['CREDIT_DAY_OVERDUE']>=60)&(bureau['CREDIT_DAY_OVERDUE']<90)].groupby('SK_ID_CURR')['CREDIT_DAY_OVERDUE'].count().to_frame().rename({'CREDIT_DAY_OVERDUE':'cb_no_CREDIT_DAY_OVERDUE_60_90'}, axis=1).reset_index()
DPD_cb_more_90=bureau[bureau['CREDIT_DAY_OVERDUE']>90].groupby('SK_ID_CURR')['CREDIT_DAY_OVERDUE'].count().to_frame().rename({'CREDIT_DAY_OVERDUE':'cb_no_CREDIT_DAY_OVERDUE_90'}, axis=1).reset_index()

#bureau=bureau.fillna(0)

credit_prolong=bureau.groupby('SK_ID_CURR').agg({'CNT_CREDIT_PROLONG':['max','min', 'mean','median']})
credit_prolong.columns = credit_prolong.columns.map('_'.join)
credit_prolong=credit_prolong.reset_index()

bureau['debt_limit_ratio_cb']=bureau['AMT_CREDIT_SUM_DEBT']/bureau['AMT_CREDIT_SUM_LIMIT']
bureau['debt_limit_ratio_over30_cb']=bureau['debt_limit_ratio_cb']>0.3
debt_limit_ratio_over30_cb=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR')['debt_limit_ratio_over30_cb'].sum().to_frame().rename({'debt_limit_ratio_over30_cb':'no_debt_limit_ratio_over30_cb'}, axis=1).reset_index()

cb_debt_limit_ratio=bureau.groupby('SK_ID_CURR').agg({'debt_limit_ratio_cb':['min','max','mean','median']})
cb_debt_limit_ratio.columns = cb_debt_limit_ratio.columns.map('_'.join)
cb_debt_limit_ratio=cb_debt_limit_ratio.reset_index()

bureau_credit_amount=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR').agg({'AMT_CREDIT_MAX_OVERDUE':['max','min', 'mean','median','sum'],'AMT_CREDIT_SUM':['sum','max','min', 'mean','median'],
                                                       'AMT_CREDIT_SUM_OVERDUE':['sum','max','min', 'mean','median'],'AMT_CREDIT_SUM_DEBT':'sum'})

bureau_credit_amount.columns = bureau_credit_amount.columns.map('_'.join)
bureau_credit_amount=bureau_credit_amount.reset_index()

cb_credit_type= bureau.groupby('SK_ID_CURR')['CREDIT_TYPE'].value_counts().to_frame().rename({'CREDIT_TYPE':'no_CREDIT_TYPE'}, axis=1).reset_index()
cb_credit_type=cb_credit_type.pivot(index='SK_ID_CURR', columns='CREDIT_TYPE', values='no_CREDIT_TYPE')

credit_type_debt=bureau.groupby(['SK_ID_CURR','CREDIT_TYPE'])['AMT_CREDIT_SUM_DEBT'].sum().to_frame().rename({'AMT_CREDIT_SUM_DEBT':'credit_Type_debt'}, axis=1).reset_index()
credit_type_debt=credit_type_debt.pivot(index='SK_ID_CURR', columns='CREDIT_TYPE', values='credit_Type_debt')
credit_type_debt=credit_type_debt.reset_index()
credit_type_debt=credit_type_debt.fillna(0)
L_1=credit_type_debt.columns[1:]
L_2=[str(col) + '_sum_debt' for col in L_1]
credit_type_debt.rename(columns=dict(zip(L_1, L_2)),inplace=True)

#bureau['cb_payment_per_month']=bureau['AMT_CREDIT_SUM']/(bureau['cb_credit_term']/30)

#payment_per_month=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR').agg({'cb_payment_per_month':['sum']})
#payment_per_month.columns = payment_per_month.columns.map('_'.join)
#payment_per_month=payment_per_month.reset_index()

previous_credit_monthly_status=bureau.groupby('SK_ID_CURR').agg({'1':['min','max','sum','mean','median'],'2':['min','max','sum','mean','median'],
                                                                 '3':['min','max','sum','mean','median'],'4':['min','max','sum','mean','median'],
                                                                 '5':['min','max','sum','mean','median'],'cb_DPD_1_5_tot':['min','max','sum','mean','median']})

previous_credit_monthly_status.columns = previous_credit_monthly_status.columns.map('_'.join)
previous_credit_monthly_status=previous_credit_monthly_status.reset_index()

bureau['debt_AMT_ratio']=bureau['AMT_CREDIT_SUM_DEBT']/bureau['AMT_CREDIT_SUM']

debt_AMT_ratio=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR').agg({'debt_AMT_ratio':['max','min', 'mean','median']})

debt_AMT_ratio.columns = debt_AMT_ratio.columns.map('_'.join)
debt_AMT_ratio=debt_AMT_ratio.reset_index()

total_debt_AMT_ratio=bureau[bureau['CREDIT_ACTIVE']=='Active'].groupby('SK_ID_CURR').agg({'AMT_CREDIT_SUM_DEBT':'sum','AMT_CREDIT_SUM':'sum'})
total_debt_AMT_ratio['total_debt_AMT_ratio']=total_debt_AMT_ratio['AMT_CREDIT_SUM_DEBT']/total_debt_AMT_ratio['AMT_CREDIT_SUM']
total_debt_AMT_ratio=total_debt_AMT_ratio.reset_index()

"""**Adding bureau features to train**"""

train=train.merge(last_month_closed,on='SK_ID_CURR', how='left')
train=train.merge(no_cb_past_loans,on='SK_ID_CURR', how='left')
train=train.merge(bureau_credit_age,on='SK_ID_CURR', how='left')
train=train.merge(bureau_credit_update,on='SK_ID_CURR', how='left')
train=train.merge(credit_status,on='SK_ID_CURR', how='left')
train=train.merge(debt_currency,on='SK_ID_CURR', how='left')
train=train.merge(delayed_credits[['SK_ID_CURR','ratio_delayed_credits_cb','no_delayed_credits']], on='SK_ID_CURR', how='left')
train=train.merge(bureau_days_stat, on='SK_ID_CURR', how='left')
train=train.merge(credit_prolong, on='SK_ID_CURR', how='left')
train=train.merge(bureau_credit_amount, on='SK_ID_CURR', how='left')
train=train.merge(cb_credit_type, on='SK_ID_CURR', how='left')
train=train.merge(credit_type_debt, on='SK_ID_CURR', how='left')
#train=train.merge(payment_per_month, on='SK_ID_CURR', how='left')
train=train.merge(previous_credit_monthly_status, on='SK_ID_CURR', how='left')
train=train.merge(debt_AMT_ratio, on='SK_ID_CURR', how='left')
train=train.merge(total_debt_AMT_ratio[['SK_ID_CURR','total_debt_AMT_ratio']], on='SK_ID_CURR', how='left')
train=train.merge(debt_limit_ratio_over30_cb,on='SK_ID_CURR', how='left')
train=train.merge(cb_debt_limit_ratio,on='SK_ID_CURR', how='left')
train=train.merge(DPD_cb_less_60,on='SK_ID_CURR', how='left')
train=train.merge(DPD_cb_less_90,on='SK_ID_CURR', how='left')
train=train.merge(DPD_cb_more_90,on='SK_ID_CURR', how='left')

"""**Adding bureau features to test**"""

test=test.merge(last_month_closed,on='SK_ID_CURR', how='left')
test=test.merge(no_cb_past_loans,on='SK_ID_CURR', how='left')
test=test.merge(bureau_credit_age,on='SK_ID_CURR', how='left')
test=test.merge(bureau_credit_update,on='SK_ID_CURR', how='left')
test=test.merge(credit_status,on='SK_ID_CURR', how='left')
test=test.merge(debt_currency,on='SK_ID_CURR', how='left')
test=test.merge(delayed_credits[['SK_ID_CURR','ratio_delayed_credits_cb','no_delayed_credits']], on='SK_ID_CURR', how='left')
test=test.merge(bureau_days_stat, on='SK_ID_CURR', how='left')
test=test.merge(credit_prolong, on='SK_ID_CURR', how='left')
test=test.merge(bureau_credit_amount, on='SK_ID_CURR', how='left')
test=test.merge(cb_credit_type, on='SK_ID_CURR', how='left')
test=test.merge(credit_type_debt, on='SK_ID_CURR', how='left')
#test=test.merge(payment_per_month, on='SK_ID_CURR', how='left')
test=test.merge(previous_credit_monthly_status, on='SK_ID_CURR', how='left')
test=test.merge(debt_AMT_ratio, on='SK_ID_CURR', how='left')
test=test.merge(total_debt_AMT_ratio[['SK_ID_CURR','total_debt_AMT_ratio']], on='SK_ID_CURR', how='left')
test=test.merge(debt_limit_ratio_over30_cb,on='SK_ID_CURR', how='left')
test=test.merge(cb_debt_limit_ratio,on='SK_ID_CURR', how='left')
test=test.merge(DPD_cb_less_60,on='SK_ID_CURR', how='left')
test=test.merge(DPD_cb_less_90,on='SK_ID_CURR', how='left')
test=test.merge(DPD_cb_more_90,on='SK_ID_CURR', how='left')

del bureau, bureau_balance, credit_status ,debt_currency, delayed_credits, bureau_days_stat, credit_prolong, bureau_credit_amount, credit_type_debt, previous_credit_monthly_status, debt_AMT_ratio,total_debt_AMT_ratio
del debt_limit_ratio_over30_cb,DPD_cb_less_60,DPD_cb_less_90,DPD_cb_more_90,bureau_credit_update,cb_credit_type,no_cb_past_loans,cb_debt_limit_ratio #, payment_per_month
gc.collect()

"""**Credit Card Balance features**

replacing outliers
"""

credit_card_balance.loc[credit_card_balance['AMT_PAYMENT_CURRENT'] > 4000000, 'AMT_PAYMENT_CURRENT'] = np.nan
credit_card_balance.loc[credit_card_balance['AMT_CREDIT_LIMIT_ACTUAL'] > 1000000, 'AMT_CREDIT_LIMIT_ACTUAL'] = np.nan

#credit_card_balance=credit_card_balance.fillna(0)

credit_card_balance=credit_card_balance.merge(previous_application[['SK_ID_PREV','AMT_CREDIT']], on='SK_ID_PREV', how='left')

credit_card_Active_balance_AMT=credit_card_balance[credit_card_balance['NAME_CONTRACT_STATUS']=='Active'].groupby('SK_ID_CURR').agg({'AMT_BALANCE':['sum','max','min', 'mean','median'], 'AMT_CREDIT':['sum','max','min', 'mean','median']})

credit_card_Active_balance_AMT.columns = credit_card_Active_balance_AMT.columns.map('_'.join)
credit_card_Active_balance_AMT=credit_card_Active_balance_AMT.reset_index()

train=train.merge(credit_card_Active_balance_AMT,on='SK_ID_CURR', how='left')
test=test.merge(credit_card_Active_balance_AMT,on='SK_ID_CURR', how='left')
del credit_card_Active_balance_AMT
gc.collect()

credit_card_balance['CC_TOT_RECEIVABLE_AMT_RECIVABLE'] = credit_card_balance['AMT_TOTAL_RECEIVABLE'] - credit_card_balance['AMT_RECIVABLE']
credit_card_balance['CC_AMT_TOTAL_RECEIVABLE_AMT_RECEIVABLE_PRINCIPAL'] = credit_card_balance['AMT_TOTAL_RECEIVABLE'] - credit_card_balance['AMT_RECEIVABLE_PRINCIPAL']
credit_card_balance['CC_AMT_RECIVABLE_AMT_RECEIVABLE_PRINCIPAL'] = credit_card_balance['AMT_RECIVABLE'] - credit_card_balance['AMT_RECEIVABLE_PRINCIPAL']

credit_card_balance['CC_AMT_BALANCE_AMT_RECIVABLE'] = credit_card_balance['AMT_BALANCE'] - credit_card_balance['AMT_RECIVABLE']
credit_card_balance['CC_AMT_BALANCE_AMT_RECEIVABLE_PRINCIPAL'] =credit_card_balance['AMT_BALANCE'] - credit_card_balance['AMT_RECEIVABLE_PRINCIPAL']
credit_card_balance['CC_AMT_BALANCE_AMT_TOTAL_RECEIVABLE'] = credit_card_balance['AMT_BALANCE'] - credit_card_balance['AMT_TOTAL_RECEIVABLE']

Receivable_Balance=credit_card_balance.groupby('SK_ID_CURR').agg({'CC_TOT_RECEIVABLE_AMT_RECIVABLE':['min','max','mean','sum'],'CC_AMT_TOTAL_RECEIVABLE_AMT_RECEIVABLE_PRINCIPAL':['min','max','mean','sum'],
                                                                  'CC_AMT_RECIVABLE_AMT_RECEIVABLE_PRINCIPAL':['min','max','mean','sum'],'CC_AMT_BALANCE_AMT_RECIVABLE':['min','max','mean','sum'],
                                                                 'CC_AMT_BALANCE_AMT_RECEIVABLE_PRINCIPAL':['min','max','mean','sum'],'CC_AMT_BALANCE_AMT_TOTAL_RECEIVABLE':['min','max','mean','sum'] })

Receivable_Balance.columns = Receivable_Balance.columns.map('_'.join)
Receivable_Balance=Receivable_Balance.reset_index()

train=train.merge(Receivable_Balance,on='SK_ID_CURR', how='left')
test=test.merge(Receivable_Balance,on='SK_ID_CURR', how='left')
del Receivable_Balance
gc.collect()

balance_AMT_DRAWINGS= credit_card_balance.groupby('SK_ID_CURR').agg({'AMT_DRAWINGS_ATM_CURRENT':['min','max','mean','sum'],'AMT_DRAWINGS_CURRENT':['min','max','mean','sum'],'AMT_BALANCE':['min','max','mean','sum']})

balance_AMT_DRAWINGS.columns = balance_AMT_DRAWINGS.columns.map('_'.join)
balance_AMT_DRAWINGS=balance_AMT_DRAWINGS.reset_index()

train=train.merge(balance_AMT_DRAWINGS,on='SK_ID_CURR', how='left')
test=test.merge(balance_AMT_DRAWINGS,on='SK_ID_CURR', how='left')
del balance_AMT_DRAWINGS
gc.collect()

credit_card_balance['balance_limit_ratio']=credit_card_balance['AMT_BALANCE']/credit_card_balance['AMT_CREDIT_LIMIT_ACTUAL']
credit_card_balance['balance_limit_ratio_over_30perc']=credit_card_balance['balance_limit_ratio']>0.3
credit_card_balance['min_inst_vs_pay']=credit_card_balance['AMT_INST_MIN_REGULARITY']-credit_card_balance['AMT_PAYMENT_TOTAL_CURRENT']
credit_card_balance['pay_less_min_inst']=credit_card_balance['min_inst_vs_pay']>0

CC_balance_limit_ratio=credit_card_balance.groupby('SK_ID_CURR').agg({'balance_limit_ratio':['min','max','mean']})
CC_balance_limit_ratio.columns = CC_balance_limit_ratio.columns.map('_'.join)
CC_balance_limit_ratio=CC_balance_limit_ratio.reset_index()

train=train.merge(CC_balance_limit_ratio,on='SK_ID_CURR', how='left')
test=test.merge(CC_balance_limit_ratio,on='SK_ID_CURR', how='left')
del CC_balance_limit_ratio
gc.collect()

temp1=credit_card_balance.groupby('SK_ID_CURR')['pay_less_min_inst'].sum().to_frame().rename({'pay_less_min_inst':'tot_pay_less_min_inst'}, axis=1).reset_index()
temp2=credit_card_balance.groupby('SK_ID_CURR')['MONTHS_BALANCE'].count().to_frame().rename({'MONTHS_BALANCE':'tot_obs'}, axis=1).reset_index()
ratio_month_paid_less_min=temp2.merge(temp1, on='SK_ID_CURR', how='left')
ratio_month_paid_less_min['ratio_month_paid_less_min']=ratio_month_paid_less_min['tot_pay_less_min_inst']/ratio_month_paid_less_min['tot_obs']

train=train.merge(ratio_month_paid_less_min[['SK_ID_CURR','ratio_month_paid_less_min']],on='SK_ID_CURR', how='left')
test=test.merge(ratio_month_paid_less_min[['SK_ID_CURR','ratio_month_paid_less_min']],on='SK_ID_CURR', how='left')
del ratio_month_paid_less_min,temp1, temp2
gc.collect()

tot_balance_limit_ratio_over30p=credit_card_balance.groupby('SK_ID_CURR')['balance_limit_ratio_over_30perc'].sum().to_frame().rename({'balance_limit_ratio_over_30perc':'no_balance_limit_ratio_over_30perc'}, axis=1).reset_index()

train=train.merge(tot_balance_limit_ratio_over30p,on='SK_ID_CURR', how='left')
test=test.merge(tot_balance_limit_ratio_over30p,on='SK_ID_CURR', how='left')
del tot_balance_limit_ratio_over30p
gc.collect()

last_month_balance_ratio=credit_card_balance[(credit_card_balance['MONTHS_BALANCE']==-1)&(credit_card_balance['balance_limit_ratio']>0.3)]
last_month_balance_ratio=last_month_balance_ratio.groupby('SK_ID_CURR')['balance_limit_ratio'].count().to_frame().rename({'balance_limit_ratio':'CNT_last_month_over_30perc'}, axis=1).reset_index()

train=train.merge(last_month_balance_ratio,on='SK_ID_CURR', how='left')
test=test.merge(last_month_balance_ratio,on='SK_ID_CURR', how='left')
del last_month_balance_ratio
gc.collect()

last_month_spent_vs_limit=credit_card_balance[credit_card_balance['MONTHS_BALANCE']==-1]
last_month_spent_vs_limit=last_month_spent_vs_limit.groupby('SK_ID_CURR').agg({'AMT_BALANCE':'sum', 'AMT_CREDIT_LIMIT_ACTUAL': 'sum'})
last_month_spent_vs_limit=last_month_spent_vs_limit.reset_index()
last_month_spent_vs_limit['total_LM_balance_limit_ratio']=last_month_spent_vs_limit['AMT_BALANCE']/last_month_spent_vs_limit['AMT_CREDIT_LIMIT_ACTUAL']
last_month_spent_vs_limit['total_last_month_balance_over_30perc']=last_month_spent_vs_limit['total_LM_balance_limit_ratio']>0.3

train=train.merge(last_month_spent_vs_limit[['SK_ID_CURR','total_last_month_balance_over_30perc']],on='SK_ID_CURR', how='left')
test=test.merge(last_month_spent_vs_limit[['SK_ID_CURR','total_last_month_balance_over_30perc']],on='SK_ID_CURR', how='left')
del last_month_spent_vs_limit
gc.collect()

#train['total_last_month_balance_over_30perc']=train['total_last_month_balance_over_30perc'].fillna(0)
#test['total_last_month_balance_over_30perc']=test['total_last_month_balance_over_30perc'].fillna(0)

credit_card_balance['DPD_considered']=credit_card_balance['SK_DPD']-credit_card_balance['SK_DPD_DEF']
DPD_credit_card_less_60=credit_card_balance[(credit_card_balance['DPD_considered']>=30)&(credit_card_balance['DPD_considered']<60)].groupby('SK_ID_CURR')['DPD_considered'].count().to_frame().rename({'DPD_considered':'DPD_Credit_card_30_60'}, axis=1).reset_index()
DPD_credit_card_less_90=credit_card_balance[(credit_card_balance['DPD_considered']>=60)&(credit_card_balance['DPD_considered']<90)].groupby('SK_ID_CURR')['DPD_considered'].count().to_frame().rename({'DPD_considered':'DPD_Credit_card_60_90'}, axis=1).reset_index()
DPD_credit_card_more_90=credit_card_balance[credit_card_balance['DPD_considered']>=90].groupby('SK_ID_CURR')['DPD_considered'].count().to_frame().rename({'DPD_considered':'DPD_Credit_card_90'}, axis=1).reset_index()

train=train.merge(DPD_credit_card_less_60,on='SK_ID_CURR', how='left')
test=test.merge(DPD_credit_card_less_60,on='SK_ID_CURR', how='left')
train=train.merge(DPD_credit_card_less_90,on='SK_ID_CURR', how='left')
test=test.merge(DPD_credit_card_less_90,on='SK_ID_CURR', how='left')
train=train.merge(DPD_credit_card_more_90,on='SK_ID_CURR', how='left')
test=test.merge(DPD_credit_card_more_90,on='SK_ID_CURR', how='left')
del DPD_credit_card_less_60,DPD_credit_card_less_90,DPD_credit_card_more_90
gc.collect()

tot_last_month_ins=credit_card_balance[(credit_card_balance['MONTHS_BALANCE']==-1)&(credit_card_balance['NAME_CONTRACT_STATUS']=='Active')].groupby(['SK_ID_CURR'])['AMT_INST_MIN_REGULARITY'].sum().to_frame().rename({'AMT_INST_MIN_REGULARITY':'tot_last_month_ins'}, axis=1).reset_index()

train=train.merge(tot_last_month_ins,on='SK_ID_CURR', how='left')
test=test.merge(tot_last_month_ins,on='SK_ID_CURR', how='left')
del tot_last_month_ins
gc.collect()

"""**Installment Payments features**

Replacing outliers
"""

installments_payments.loc[installments_payments['DAYS_ENTRY_PAYMENT'] < -4000, 'DAYS_ENTRY_PAYMENT'] = np.nan

#installments_payments=installments_payments[installments_payments['NUM_INSTALMENT_VERSION']!=0]&(installments_payments['DAYS_INSTALMENT']>-2555)]

#installments_payments=installments_payments.fillna(0)

installment_aggs=installments_payments.groupby('SK_ID_CURR').agg({'AMT_INSTALMENT':['mean', 'min', 'max', 'sum', 'var'],'AMT_PAYMENT':['mean', 'min', 'max', 'sum', 'var'],'DAYS_ENTRY_PAYMENT':['mean', 'min', 'max', 'sum', 'var'],
                                                                  'DAYS_INSTALMENT':['mean', 'min', 'max', 'sum', 'var'],'NUM_INSTALMENT_NUMBER':['mean', 'min', 'max', 'sum', 'var'],
                                                                  'NUM_INSTALMENT_VERSION':['mean', 'min', 'max', 'sum', 'var']})

installment_aggs.columns = installment_aggs.columns.map('_'.join)
installment_aggs=installment_aggs.reset_index()

train=train.merge(installment_aggs,on='SK_ID_CURR', how='left')
test=test.merge(installment_aggs,on='SK_ID_CURR', how='left')
del installment_aggs
gc.collect()

installments_payments['DPD_instalment_payments']=installments_payments['DAYS_ENTRY_PAYMENT']-installments_payments['DAYS_INSTALMENT']
installments_payments['Low_paid_installment_payments']=installments_payments['AMT_INSTALMENT']-installments_payments['AMT_PAYMENT']

installment_DPD_less_60=installments_payments[(installments_payments['DPD_instalment_payments']>=30)&(installments_payments['DPD_instalment_payments']<60)].groupby('SK_ID_CURR')['DPD_instalment_payments'].count().to_frame().rename({'DPD_instalment_payments':'DPD_instalment_payments_30_60'}, axis=1).reset_index()
installment_DPD_less_90=installments_payments[(installments_payments['DPD_instalment_payments']>=60)&(installments_payments['DPD_instalment_payments']<90)].groupby('SK_ID_CURR')['DPD_instalment_payments'].count().to_frame().rename({'DPD_instalment_payments':'DPD_instalment_payments_60_90'}, axis=1).reset_index()
installment_DPD_more_90=installments_payments[installments_payments['DPD_instalment_payments']>=90].groupby('SK_ID_CURR')['DPD_instalment_payments'].count().to_frame().rename({'DPD_instalment_payments':'DPD_instalment_payments_90'}, axis=1).reset_index()

train=train.merge(installment_DPD_less_60,on='SK_ID_CURR', how='left')
test=test.merge(installment_DPD_less_60,on='SK_ID_CURR', how='left')
train=train.merge(installment_DPD_less_90,on='SK_ID_CURR', how='left')
test=test.merge(installment_DPD_less_90,on='SK_ID_CURR', how='left')
train=train.merge(installment_DPD_more_90,on='SK_ID_CURR', how='left')
test=test.merge(installment_DPD_more_90,on='SK_ID_CURR', how='left')
del installment_DPD_less_60,installment_DPD_less_90,installment_DPD_more_90
gc.collect()

installment_low_paid=installments_payments[installments_payments['Low_paid_installment_payments']>0].groupby('SK_ID_CURR')['Low_paid_installment_payments'].count().to_frame().rename({'Low_paid_installment_payments':'no_Low_paid_installment_payments'}, axis=1).reset_index()

train=train.merge(installment_low_paid,on='SK_ID_CURR', how='left')
test=test.merge(installment_low_paid,on='SK_ID_CURR', how='left')
del installment_low_paid
gc.collect()

"""**POS_CASH Balance features**

Filtering last 7 years records
"""

#POS_CASH_balance=POS_CASH_balance[POS_CASH_balance['MONTHS_BALANCE']>-2555]

no_name_contract=POS_CASH_balance.groupby(['SK_ID_CURR','NAME_CONTRACT_STATUS'])['NAME_CONTRACT_STATUS'].count().to_frame().rename({'NAME_CONTRACT_STATUS':'no_NAME_CONTRACT_STATUS'}, axis=1).reset_index()
no_name_contract=no_name_contract.pivot(index='SK_ID_CURR', columns='NAME_CONTRACT_STATUS', values='no_NAME_CONTRACT_STATUS').fillna(0).reset_index()
L=no_name_contract.columns[1:]
#Ratio_name_contract['tot_name_contract']=Ratio_name_contract[L].sum(axis=1)

for col in L:
  no_name_contract['POS_'+col]=no_name_contract[col]#/Ratio_name_contract['tot_name_contract']
  no_name_contract=no_name_contract.drop([col], axis=1)
#Ratio_name_contract=Ratio_name_contract.drop('tot_name_contract', axis=1)

train=train.merge(no_name_contract,on='SK_ID_CURR', how='left')
test=test.merge(no_name_contract,on='SK_ID_CURR', how='left')
del no_name_contract
gc.collect()

#POS_CASH_balance['considered_DPD']=POS_CASH_balance['SK_DPD']-POS_CASH_balance['SK_DPD_DEF']
#DPD_CASH_balance_less_60=POS_CASH_balance[(POS_CASH_balance['considered_DPD']>=30)&(POS_CASH_balance['considered_DPD']<60)].groupby('SK_ID_CURR')['considered_DPD'].count().to_frame().rename({'considered_DPD':'DPD_POS_CASH_30_60'}, axis=1).reset_index()
#DPD_CASH_balance_less_90=POS_CASH_balance[(POS_CASH_balance['considered_DPD']>=60)&(POS_CASH_balance['considered_DPD']<90)].groupby('SK_ID_CURR')['considered_DPD'].count().to_frame().rename({'considered_DPD':'DPD_POS_CASH_60_90'}, axis=1).reset_index()
#DPD_CASH_balance_more_90=POS_CASH_balance[POS_CASH_balance['considered_DPD']>=90].groupby('SK_ID_CURR')['considered_DPD'].count().to_frame().rename({'considered_DPD':'DPD_POS_CASH_90'}, axis=1).reset_index()

POS_Active_annuity=POS_CASH_balance.groupby(['SK_ID_PREV','SK_ID_CURR'])['MONTHS_BALANCE'].max().to_frame().reset_index()
POS_Active_annuity=POS_Active_annuity.merge(POS_CASH_balance, on=['SK_ID_PREV','SK_ID_CURR','MONTHS_BALANCE'], how='left')
POS_Active_annuity['current_Active_credit']=POS_Active_annuity['CNT_INSTALMENT_FUTURE']+POS_Active_annuity['MONTHS_BALANCE']
POS_Active_annuity['current_Active_credit']=POS_Active_annuity['current_Active_credit']>0
POS_Active_annuity=POS_Active_annuity[(POS_Active_annuity['current_Active_credit']>0)&(POS_Active_annuity['NAME_CONTRACT_STATUS']!='Returned to the store')]
POS_Active_annuity=POS_Active_annuity.drop(['CNT_INSTALMENT','SK_DPD','SK_DPD_DEF'], axis=1)
POS_Active_annuity=POS_Active_annuity.merge(previous_application[['SK_ID_PREV','AMT_ANNUITY']], on='SK_ID_PREV', how='left')
POS_Active_annuity=POS_Active_annuity.fillna(0)
POS_Active_annuity=POS_Active_annuity.groupby('SK_ID_CURR')['AMT_ANNUITY'].sum().to_frame().rename({'AMT_ANNUITY':'POS_AMT_ANNUITY'}, axis=1).reset_index()

#train=train.merge(POS_Active_annuity,on='SK_ID_CURR', how='left')
#test=test.merge(POS_Active_annuity,on='SK_ID_CURR', how='left')
#del POS_Active_annuity
#gc.collect()

"""**Previous application features**"""

previous_application.loc[previous_application['AMT_CREDIT'] > 6000000, 'AMT_CREDIT'] = np.nan
previous_application.loc[previous_application['SELLERPLACE_AREA'] > 3500000, 'SELLERPLACE_AREA'] = np.nan
previous_application[['DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION', 
             'DAYS_LAST_DUE', 'DAYS_TERMINATION']].replace(365243, np.nan, inplace = True)

HC_customer_credit_age=previous_application[previous_application['NAME_CONTRACT_STATUS']=='Approved'].groupby('SK_ID_CURR').agg({'DAYS_DECISION':['max','min','mean']})

HC_customer_credit_age.columns = HC_customer_credit_age.columns.map('_'.join)
HC_customer_credit_age=HC_customer_credit_age.reset_index()

train=train.merge(HC_customer_credit_age,on='SK_ID_CURR', how='left')
test=test.merge(HC_customer_credit_age,on='SK_ID_CURR', how='left')
del HC_customer_credit_age
gc.collect()

previous_application['prev_app_credit_ratio']=previous_application['AMT_APPLICATION'] / previous_application['AMT_CREDIT']
previous_application['prev_GOODS_AMT_CREDIT'] = previous_application['AMT_GOODS_PRICE'] - previous_application['AMT_CREDIT']

prev_app_agg=previous_application.groupby('SK_ID_CURR').agg({'prev_app_credit_ratio':['min','max','mean'],'prev_GOODS_AMT_CREDIT':['min','max','mean']})
prev_app_agg.columns = prev_app_agg.columns.map('_'.join)
prev_app_agg=prev_app_agg.reset_index()

train=train.merge(prev_app_agg,on='SK_ID_CURR', how='left')
test=test.merge(prev_app_agg,on='SK_ID_CURR', how='left')
del prev_app_agg
gc.collect()

loan_approval_6M=previous_application[(previous_application['DAYS_DECISION']>-180)&(previous_application['FLAG_LAST_APPL_PER_CONTRACT']=='Y')].groupby('SK_ID_CURR')['NAME_CONTRACT_STATUS'].value_counts().to_frame().rename({'NAME_CONTRACT_STATUS':'CONTRACT_STATUS_6M'}, axis=1).reset_index()
loan_approval_6M=loan_approval_6M.pivot(index='SK_ID_CURR', columns='NAME_CONTRACT_STATUS', values='CONTRACT_STATUS_6M').fillna(0).reset_index()
L_1=loan_approval_6M.columns[1:]
L_2=[str(col) + '_6M' for col in L_1]
loan_approval_6M.rename(columns=dict(zip(L_1, L_2)),inplace=True)
loan_approval_6M['tot_no_HC_credit_6M']=loan_approval_6M.iloc[:,1:].sum(axis=1)

for col in L_2:
  loan_approval_6M['HC_'+col]=loan_approval_6M[col]#/Ratio_loan_approval_6M['tot_no_credit']
  loan_approval_6M.drop([col], axis=1, inplace=True)
#Ratio_loan_approval_6M.drop('tot_no_credit', axis=1, inplace=True)

train=train.merge(loan_approval_6M,on='SK_ID_CURR', how='left')
test=test.merge(loan_approval_6M,on='SK_ID_CURR', how='left')
del loan_approval_6M
gc.collect()

loan_approval_12M=previous_application[(previous_application['DAYS_DECISION']<-180)&(previous_application['DAYS_DECISION']>-360)&(previous_application['FLAG_LAST_APPL_PER_CONTRACT']=='Y')].groupby('SK_ID_CURR')['NAME_CONTRACT_STATUS'].value_counts().to_frame().rename({'NAME_CONTRACT_STATUS':'CONTRACT_STATUS_12M'}, axis=1).reset_index()
loan_approval_12M=loan_approval_12M.pivot(index='SK_ID_CURR', columns='NAME_CONTRACT_STATUS', values='CONTRACT_STATUS_12M').fillna(0).reset_index()
L_1=loan_approval_12M.columns[1:]
L_2=[str(col) + '_12M' for col in L_1]
loan_approval_12M.rename(columns=dict(zip(L_1, L_2)),inplace=True)
loan_approval_12M['tot_no_HC_credit_12M']=loan_approval_12M.iloc[:,1:].sum(axis=1)

for col in L_2:
  loan_approval_12M['HC_'+col]=loan_approval_12M[col]#/Ratio_loan_approval_12M['tot_no_credit']
  loan_approval_12M.drop([col], axis=1, inplace=True)
#Ratio_loan_approval_12M.drop('tot_no_credit', axis=1, inplace=True)

train=train.merge(loan_approval_12M,on='SK_ID_CURR', how='left')
test=test.merge(loan_approval_12M,on='SK_ID_CURR', how='left')
del loan_approval_12M
gc.collect()

"""## **Train features & Data Prep**"""

train['CODE_GENDER'].replace('XNA', np.nan, inplace=True)
train['DAYS_EMPLOYED'].replace(365243, np.nan, inplace=True)
train.loc[train['OWN_CAR_AGE'] > 80, 'OWN_CAR_AGE'] = np.nan
train['NAME_FAMILY_STATUS'].replace('Unknown', np.nan, inplace=True)
train['ORGANIZATION_TYPE'].replace('XNA', np.nan, inplace=True)
train['DAYS_LAST_PHONE_CHANGE'].replace(0, np.nan, inplace=True)
train.loc[train['REGION_RATING_CLIENT_W_CITY'] < 0, 'REGION_RATING_CLIENT_W_CITY'] = np.nan
train.loc[train['AMT_INCOME_TOTAL'] > 1e8, 'AMT_INCOME_TOTAL'] = np.nan

test['CODE_GENDER'].replace('XNA', np.nan, inplace=True)
test['DAYS_EMPLOYED'].replace(365243, np.nan, inplace=True)
test.loc[test['OWN_CAR_AGE'] > 80, 'OWN_CAR_AGE'] = np.nan
test['NAME_FAMILY_STATUS'].replace('Unknown', np.nan, inplace=True)
test['ORGANIZATION_TYPE'].replace('XNA', np.nan, inplace=True)
test['DAYS_LAST_PHONE_CHANGE'].replace(0, np.nan, inplace=True)
test.loc[test['REGION_RATING_CLIENT_W_CITY'] < 0, 'REGION_RATING_CLIENT_W_CITY'] = np.nan
test.loc[test['AMT_INCOME_TOTAL'] > 1e8, 'AMT_INCOME_TOTAL'] = np.nan

"""Customer's Credit Age"""

train['customers_credit_Age']=train[['DAYS_DECISION_min','DAYS_CREDIT_min']].min(axis=1)

#df=pd.concat([train,test]).reset_index(drop=True)
#mean_car_age=df.groupby('FLAG_OWN_CAR')['OWN_CAR_AGE'].mean().to_frame().iloc[1,0]
#df['OWN_CAR_AGE']=df.loc[df['FLAG_OWN_CAR']=='Y','OWN_CAR_AGE'].fillna(mean_car_age)
#df['OWN_CAR_AGE']=df['OWN_CAR_AGE'].fillna(9999)
#train=df.iloc[:len(train)].reset_index(drop=True)
#test=df.iloc[len(train):].drop('TARGET', axis=1).reset_index(drop=True)
#del df
#gc.collect()

train['ratio_OWN_CAR_AGE_DAYS_BIRTH'] = train['OWN_CAR_AGE'] / train['DAYS_BIRTH']
train['ratio_OWN_CAR_AGE_DAYS_EMPLOYED'] = train['OWN_CAR_AGE'] / train['DAYS_EMPLOYED']

test['ratio_OWN_CAR_AGE_DAYS_BIRTH'] = test['OWN_CAR_AGE'] / test['DAYS_BIRTH']
test['ratio_OWN_CAR_AGE_DAYS_EMPLOYED'] = test['OWN_CAR_AGE'] / test['DAYS_EMPLOYED']

train['days_employed_percentage'] = train['DAYS_EMPLOYED'] / train['DAYS_BIRTH']
test['days_employed_percentage'] = test['DAYS_EMPLOYED'] / test['DAYS_BIRTH']

train['children_ratio'] = train['CNT_CHILDREN'] / train['CNT_FAM_MEMBERS']
train['income_per_child'] = train['AMT_INCOME_TOTAL'] / (1 + train['CNT_CHILDREN'])
test['children_ratio'] = test['CNT_CHILDREN'] / test['CNT_FAM_MEMBERS']
test['income_per_child'] = test['AMT_INCOME_TOTAL'] / (1 + test['CNT_CHILDREN'])

train['long_employment'] = (train['DAYS_EMPLOYED'] < -2000).astype(int)
test['long_employment'] = (test['DAYS_EMPLOYED'] < -2000).astype(int)

doc_cols=[col for col in train.columns if 'FLAG_DOCUMENT' in col]

df=pd.concat([train, test]).reset_index(drop=True)
df['tot_DOCUMNETS']=df[doc_cols].sum(axis=1)

train=df.iloc[:len(train)].reset_index(drop=True)
test=df.iloc[len(train):].drop('TARGET', axis=1).reset_index(drop=True)
del df
gc.collect()

train['ext_sources_mean'] = train[['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3']].mean(axis=1)
test['ext_sources_mean'] = test[['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3']].mean(axis=1)

train['app EXT_SOURCE prod'] = train['EXT_SOURCE_1'] * train['EXT_SOURCE_2'] * train['EXT_SOURCE_3']
test['app EXT_SOURCE prod'] = test['EXT_SOURCE_1'] * test['EXT_SOURCE_2'] * test['EXT_SOURCE_3']

df=pd.concat([train,test])
Ed_OCC_EX_SRC=df.groupby(['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE']).agg({"EXT_SOURCE_1":"mean","EXT_SOURCE_2":"mean","EXT_SOURCE_3":"mean"})

Ed_OCC_EX_SRC.columns = Ed_OCC_EX_SRC.columns.map('_'.join)

for col in Ed_OCC_EX_SRC.columns:
  Ed_OCC_EX_SRC['EDUCATION_OCCUPATION'+col]=Ed_OCC_EX_SRC[col]
  Ed_OCC_EX_SRC.drop(col, axis=1, inplace=True)

Ed_OCC_EX_SRC=Ed_OCC_EX_SRC.reset_index()

train=train.merge(Ed_OCC_EX_SRC, on=['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE'], how='left')
test=test.merge(Ed_OCC_EX_SRC, on=['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE'], how='left')

del Ed_OCC_EX_SRC
gc.collect()

df=pd.concat([train,test])
Ed_OCC_Reg_EX_SRC=df.groupby(['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY']).agg({"EXT_SOURCE_1":"mean","EXT_SOURCE_2":"mean","EXT_SOURCE_3":"mean"})

Ed_OCC_Reg_EX_SRC.columns = Ed_OCC_Reg_EX_SRC.columns.map('_'.join)

for col in Ed_OCC_Reg_EX_SRC.columns:
  Ed_OCC_Reg_EX_SRC['EDUCATION_OCCUPATION_REG_CITY_NOT_WORK_CITY'+col]=Ed_OCC_Reg_EX_SRC[col]
  Ed_OCC_Reg_EX_SRC.drop(col, axis=1, inplace=True)

Ed_OCC_Reg_EX_SRC=Ed_OCC_Reg_EX_SRC.reset_index()

train=train.merge(Ed_OCC_Reg_EX_SRC, on=['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY'], how='left')
test=test.merge(Ed_OCC_Reg_EX_SRC, on=['NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY'], how='left')

del Ed_OCC_Reg_EX_SRC,df
gc.collect()

df=pd.concat([train,test])
gen_Ed_OCC_Reg_EX_SRC=df.groupby(['CODE_GENDER', 'NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY']).agg({"EXT_SOURCE_1":"mean","EXT_SOURCE_2":"mean","EXT_SOURCE_3":"mean"})

gen_Ed_OCC_Reg_EX_SRC.columns = gen_Ed_OCC_Reg_EX_SRC.columns.map('_'.join)

for col in gen_Ed_OCC_Reg_EX_SRC.columns:
  gen_Ed_OCC_Reg_EX_SRC['EDUCATION_OCCUPATION'+col]=gen_Ed_OCC_Reg_EX_SRC[col]
  gen_Ed_OCC_Reg_EX_SRC.drop(col, axis=1, inplace=True)

gen_Ed_OCC_Reg_EX_SRC=gen_Ed_OCC_Reg_EX_SRC.reset_index()

train=train.merge(gen_Ed_OCC_Reg_EX_SRC, on=['CODE_GENDER', 'NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY'], how='left')
test=test.merge(gen_Ed_OCC_Reg_EX_SRC, on=['CODE_GENDER', 'NAME_EDUCATION_TYPE', 'OCCUPATION_TYPE','REG_CITY_NOT_WORK_CITY'], how='left')

del gen_Ed_OCC_Reg_EX_SRC,df
gc.collect()

df=pd.concat([train,test])
OCC_EX_SRC=df.groupby('OCCUPATION_TYPE').agg({"EXT_SOURCE_1":"mean","EXT_SOURCE_2":"mean","EXT_SOURCE_3":"mean"})

OCC_EX_SRC.columns = OCC_EX_SRC.columns.map('_'.join)

for col in OCC_EX_SRC.columns:
  OCC_EX_SRC['OCCUPATION'+col]=OCC_EX_SRC[col]
  OCC_EX_SRC.drop(col, axis=1, inplace=True)

OCC_EX_SRC=OCC_EX_SRC.reset_index()

train=train.merge(OCC_EX_SRC, on='OCCUPATION_TYPE', how='left')
test=test.merge(OCC_EX_SRC, on='OCCUPATION_TYPE', how='left')

del OCC_EX_SRC
gc.collect()

train['AMT_GOODS_PRICE']=train['AMT_GOODS_PRICE'].fillna(0)
test['AMT_GOODS_PRICE']=test['AMT_GOODS_PRICE'].fillna(0)

train['Credit_Goods_Ratio']=train['AMT_CREDIT']/train['AMT_GOODS_PRICE']
test['Credit_Goods_Ratio']=test['AMT_CREDIT']/test['AMT_GOODS_PRICE']

train['AMT_CREDIT - AMT_GOODS_PRICE'] = train['AMT_CREDIT'] - train['AMT_GOODS_PRICE']
test['AMT_CREDIT - AMT_GOODS_PRICE'] = test['AMT_CREDIT'] - test['AMT_GOODS_PRICE']

"""changing multiple hard inquiries up to a week to 1 inquiry only for cash loans"""

inquiries=['AMT_REQ_CREDIT_BUREAU_HOUR','AMT_REQ_CREDIT_BUREAU_DAY','AMT_REQ_CREDIT_BUREAU_WEEK','AMT_REQ_CREDIT_BUREAU_MON','AMT_REQ_CREDIT_BUREAU_QRT','AMT_REQ_CREDIT_BUREAU_YEAR']
#train[inquiries]=train[inquiries].fillna(0)
#test[inquiries]=test[inquiries].fillna(0)

train['AMT_total_inquiries_upto_week']=train['AMT_REQ_CREDIT_BUREAU_HOUR']+train['AMT_REQ_CREDIT_BUREAU_DAY']+train['AMT_REQ_CREDIT_BUREAU_WEEK']
train['AMT_total_inquiries_upto_week']=train.loc[(train['AMT_total_inquiries_upto_week']>0)&(train['NAME_CONTRACT_TYPE']=='Cash loans'),'AMT_total_inquiries_upto_week']=1

test['AMT_total_inquiries_upto_week']=test['AMT_REQ_CREDIT_BUREAU_HOUR']+test['AMT_REQ_CREDIT_BUREAU_DAY']+test['AMT_REQ_CREDIT_BUREAU_WEEK']
test['AMT_total_inquiries_upto_week']=test.loc[(test['AMT_total_inquiries_upto_week']>0)&(test['NAME_CONTRACT_TYPE']=='Cash loans'),'AMT_total_inquiries_upto_week']=1

train['total_Credit_Bureau_inquiries']=train[['AMT_total_inquiries_upto_week','AMT_REQ_CREDIT_BUREAU_MON','AMT_REQ_CREDIT_BUREAU_QRT','AMT_REQ_CREDIT_BUREAU_YEAR']].sum(axis=1)
test['total_Credit_Bureau_inquiries']=test[['AMT_total_inquiries_upto_week','AMT_REQ_CREDIT_BUREAU_MON','AMT_REQ_CREDIT_BUREAU_QRT','AMT_REQ_CREDIT_BUREAU_YEAR']].sum(axis=1)

train.drop(['AMT_REQ_CREDIT_BUREAU_HOUR','AMT_REQ_CREDIT_BUREAU_DAY','AMT_REQ_CREDIT_BUREAU_WEEK'],axis=1,inplace=True)
test.drop(['AMT_REQ_CREDIT_BUREAU_HOUR','AMT_REQ_CREDIT_BUREAU_DAY','AMT_REQ_CREDIT_BUREAU_WEEK'],axis=1,inplace=True)

train['credit_to_annuity_ratio'] = train['AMT_CREDIT'] / train['AMT_ANNUITY']
test['credit_to_annuity_ratio'] = test['AMT_CREDIT'] / test['AMT_ANNUITY']

train['AMT_INCOME_TOTAL_tot_AMT_ANNUITY'] = train['AMT_INCOME_TOTAL'] / 12. - train['AMT_ANNUITY']
test['AMT_INCOME_TOTAL_tot_AMT_ANNUITY'] = test['AMT_INCOME_TOTAL'] / 12. - test['AMT_ANNUITY']

train['credit_to_income_ratio'] = train['AMT_CREDIT'] / train['AMT_INCOME_TOTAL']
test['credit_to_income_ratio'] = test['AMT_CREDIT'] / test['AMT_INCOME_TOTAL']

"""Debt to Income Ratio"""

#train['total_debt']=train['AMT_ANNUITY']+train['tot_last_month_ins']+train['POS_AMT_ANNUITY']+train['cb_payment_per_month_sum']
#train['debt_to_income_Ratio']=train['total_debt']/train['AMT_INCOME_TOTAL']


#test['total_debt']=test['AMT_ANNUITY']+test['tot_last_month_ins']+test['POS_AMT_ANNUITY']+test['cb_payment_per_month_sum']
#test['debt_to_income_Ratio']=test['total_debt']/test['AMT_INCOME_TOTAL']

train['annuity_income_percentage'] = train['AMT_ANNUITY'] / train['AMT_INCOME_TOTAL']
test['annuity_income_percentage'] = test['AMT_ANNUITY'] / test['AMT_INCOME_TOTAL']

train['ratio_AMT_INCOME_TOTAL_FAM_MEMBERS'] = train['AMT_INCOME_TOTAL'] / train['CNT_FAM_MEMBERS']
test['ratio_AMT_INCOME_TOTAL_FAM_MEMBERS'] = test['AMT_INCOME_TOTAL'] / test['CNT_FAM_MEMBERS']

train.replace([np.inf, -np.inf], 0, inplace=True)
test.replace([np.inf, -np.inf], 0, inplace=True)

"""total DPD features"""

train['total_DPD_30_60']=train['cb_no_CREDIT_DAY_OVERDUE_30_60']+train['DPD_Credit_card_30_60']+train['DPD_instalment_payments_30_60']
train['total_DPD_60_90']=train['cb_no_CREDIT_DAY_OVERDUE_60_90']+train['DPD_Credit_card_60_90']+train['DPD_instalment_payments_60_90']
train['total_DPD_90']=train['cb_no_CREDIT_DAY_OVERDUE_90']+train['DPD_Credit_card_90']+train['DPD_instalment_payments_90']

test['total_DPD_30_60']=test['cb_no_CREDIT_DAY_OVERDUE_30_60']+test['DPD_Credit_card_30_60']+test['DPD_instalment_payments_30_60']
test['total_DPD_60_90']=test['cb_no_CREDIT_DAY_OVERDUE_60_90']+test['DPD_Credit_card_60_90']+test['DPD_instalment_payments_60_90']
test['total_DPD_90']=test['cb_no_CREDIT_DAY_OVERDUE_90']+test['DPD_Credit_card_90']+test['DPD_instalment_payments_90']

#train.drop(['cb_no_CREDIT_DAY_OVERDUE_30_60','DPD_Credit_card_30_60','DPD_instalment_payments_30_60','cb_no_CREDIT_DAY_OVERDUE_60_90','DPD_Credit_card_60_90','DPD_instalment_payments_60_90','cb_no_CREDIT_DAY_OVERDUE_90','DPD_Credit_card_90','DPD_instalment_payments_90'], axis=1, inplace=True)
#test.drop(['cb_no_CREDIT_DAY_OVERDUE_30_60','DPD_Credit_card_30_60','DPD_instalment_payments_30_60','cb_no_CREDIT_DAY_OVERDUE_60_90','DPD_Credit_card_60_90','DPD_instalment_payments_60_90','cb_no_CREDIT_DAY_OVERDUE_90','DPD_Credit_card_90','DPD_instalment_payments_90'], axis=1, inplace=True)

"""### **Encoding Columns**"""

l=[col for col in train.columns if train[col].dtype in(['object', 'category'])]
l

train['total_last_month_balance_over_30perc']=train['total_last_month_balance_over_30perc'].astype('bool')
test['total_last_month_balance_over_30perc']=test['total_last_month_balance_over_30perc'].astype('bool')

train['HOUR_APPR_PROCESS_START']=train['HOUR_APPR_PROCESS_START'].astype('object')
test['HOUR_APPR_PROCESS_START']=test['HOUR_APPR_PROCESS_START'].astype('object')

map={'Lower secondary':0,'Secondary / secondary special':1,'Incomplete higher':2,'Higher education':3,'Academic degree':4 }
train['NAME_EDUCATION_TYPE']=train['NAME_EDUCATION_TYPE'].map(map)
test['NAME_EDUCATION_TYPE']=test['NAME_EDUCATION_TYPE'].map(map)

l=[col for col in train.columns if train[col].dtype in(['object', 'category'])]
l

"""frequency encode: weekday and application hour"""

weekday_fq=train.groupby('WEEKDAY_APPR_PROCESS_START').size()/len(train)
weekday_fq=weekday_fq.to_dict()
train['WEEKDAY_APPR_PROCESS_START']=train['WEEKDAY_APPR_PROCESS_START'].map(weekday_fq)
test['WEEKDAY_APPR_PROCESS_START']=test['WEEKDAY_APPR_PROCESS_START'].map(weekday_fq)

Hour_fq=train.groupby('HOUR_APPR_PROCESS_START').size()/len(train)
Hour_fq=Hour_fq.to_dict()
train['HOUR_APPR_PROCESS_START']=train['HOUR_APPR_PROCESS_START'].map(Hour_fq)
test['HOUR_APPR_PROCESS_START']=test['HOUR_APPR_PROCESS_START'].map(Hour_fq)

l=[col for col in train.columns if train[col].dtype in(['object', 'category'])]
l

for col in l:
  train[col]=train[col].fillna('Data_not_seen')
  test[col]=test[col].fillna('Data_not_seen')

for col in l:
  lbl = LabelEncoder()
  lbl.fit(list(train[col].values) + list(test[col].values))
  train[col] = lbl.transform(list(train[col].values))
  test[col] = lbl.transform(list(test[col].values))

train=train.fillna(0)
test=test.fillna(0)

"""### **Implement feature Selection**"""

for df in [train, test]:
  df.drop('SK_ID_CURR', axis=1, inplace=True)

len(train.columns)

X=train.drop('TARGET', axis=1)
y=train['TARGET']
X_test=test

from lightgbm import LGBMClassifier
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import StratifiedKFold

NFOLDS=3
skf=StratifiedKFold(n_splits=NFOLDS, shuffle=True)

clf = LGBMClassifier( 
    n_estimators= 2000,
    objective='binary',
    boosting_type= "gbdt",
    num_leaves= 1280,
    max_depth=-1,
    learning_rate= 0.1,
    reg_lambda= 50,
    colsample_bytree=0.5,
    importance_type='gain',
    metric='auc'
               )
feature_importances=np.zeros((len(X.columns),NFOLDS))
for j, (train_idx, test_idx) in enumerate(skf.split(X, y)):
    fold = j + 1
    print('Fold:',fold)

    kf_X_train=X.iloc[train_idx]
    kf_y_train=y.iloc[train_idx]
    
    kf_X_test=X.iloc[test_idx]
    kf_y_test=y.iloc[test_idx]
    h = clf.fit(kf_X_train, kf_y_train, eval_set=[(kf_X_train,kf_y_train), (kf_X_test,kf_y_test)],
              eval_names=['train', 'test'], eval_metric='auc',verbose=50, early_stopping_rounds=300)
    feature_importances[:,j]=clf.feature_importances_
f_imp=np.mean(feature_importances, axis=1)

feature_imp = pd.DataFrame(sorted(zip(f_imp,X.columns)), columns=['Value','Feature'])
plt.figure(figsize=(20, 10))
sns.barplot(x="Value", y="Feature", data=feature_imp.sort_values(by="Value", ascending=False).iloc[:30])
plt.title('LGB Feature Importance')
plt.tight_layout()
plt.show()

plt.figure(figsize=(20, 10))
sns.barplot(x="Value", y="Feature", data=feature_imp.sort_values(by="Value", ascending=False).iloc[-50:])
plt.title('LGB Feature Importance')
plt.tight_layout()
plt.show()
del clf, h; x=gc.collect()

low_importance_features=feature_imp[feature_imp['Value']==0]['Feature'].to_list()
low_importance_features

train.drop(low_importance_features, axis=1, inplace=True)
test.drop(low_importance_features, axis=1, inplace=True)

len(train.columns)

train.to_csv('HC_train.csv', index=False)
test.to_csv('HC_test.csv', index=False)

from google.colab import files

files.download('HC_train.csv')
files.download('HC_test.csv')