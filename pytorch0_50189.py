# -*- coding: utf-8 -*-
"""Home Credit Default Risk_PyTorch0.50189.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SwWsMNjEE2wneICKKkE6def-8WypKDol
"""

import numpy as np
import pandas as pd
from scipy.stats.mstats import gmean
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import roc_auc_score
from sklearn.preprocessing import MinMaxScaler

import warnings
warnings.filterwarnings('ignore')

! gdown 1oOYKhDY_sTs4Qt0dluKCnUZAAUDazSmn

! gdown 1kE8eNxJqEWmFW8BTmkuUPDxuXID4odjT

! gdown 1dVTuMbcQwYppTr9LeGe3-Aq7EAB0N7qH

train=pd.read_csv('HC_train.csv')
test=pd.read_csv('HC_test.csv')

def AUC(y_true, y_score):
  return roc_auc_score(y_true, y_score)

X=train.drop('TARGET', axis=1)
y=train['TARGET']
X_test=test

Scaler=MinMaxScaler()
X=Scaler.fit_transform(X)
X_test=Scaler.transform(X_test)

import torch
import torch.nn as nn
import torch.nn.functional as F

torch.cuda.is_available()

X=torch.tensor(X, dtype=torch.float)
X_test=torch.tensor(X_test, dtype=torch.float)
y=torch.tensor(y).flatten().cuda()
y=y.type(torch.cuda.LongTensor)

X.shape

y.shape

X_test.shape

class HCModel(nn.Module):
  def __init__(self, in_sz, out_sz, layers, p):
    super().__init__()
    layerlist=[]
    for i in layers:
      layerlist.append(nn.Linear(in_sz,i))
      layerlist.append(nn.ReLU(inplace=True))
      layerlist.append(nn.BatchNorm1d(i))
      layerlist.append(nn.Dropout(p))
      in_sz=i
    layerlist.append(nn.Linear(layers[-1], out_sz))

    self.layers=nn.Sequential(*layerlist)
  
  def forward(self, x):
    x=self.layers(x)
    return x

in_sz=X.shape[1]
out_sz=2
layers=[200,150,100,100]
p=0.5
model=HCModel(in_sz, out_sz, layers, p)
gpumodel=model.cuda()

criterion=nn.CrossEntropyLoss()
optimizer=torch.optim.Adam(model.parameters(), lr=0.01)

import time
start_time=time.time()
SEED=2022
epochs=60
n_splits=5
skf = StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=SEED)
y_pred=torch.tensor(np.zeros((X_test.shape[0],2))).cuda()
y=y.cpu()

for fold, (tr_idx, te_idx) in enumerate(skf.split(X,y)):
  kf_X_train=X[tr_idx].cuda()
  kf_y_train=y[tr_idx].cuda()
  kf_X_val=X[te_idx].cuda()
  kf_y_val=y[te_idx].cuda()
  print('Training fold:', fold+1)
  for i in range (epochs):
        i+=1
        oof_y_pred=gpumodel(kf_X_train)
        oof_y_val=gpumodel(kf_X_val)

        oof_Pred_loss=criterion(oof_y_pred,kf_y_train)
        oof_Val_loss=criterion(oof_y_val,kf_y_val)

        if i%10==0:
          print(f'epoch: {i:3}  loss: {oof_Pred_loss.item(): 8.6f}  val_loss: {oof_Val_loss.item(): 8.6f}')
        
        optimizer.zero_grad()
        oof_Pred_loss.backward()
        optimizer.step()
  with torch.no_grad() :
    X=X.cuda()
    X_test=X_test.cuda()
    y_train_pred=model(X)
    y_pred+=model(X_test)/n_splits
    y=y.cpu()
    y_train_pred=y_train_pred.cpu()
    y_train_pred_final=torch.argmax(y_train_pred, dim=1)
  print(f'fold {fold+1} AUC: {AUC(y,y_train_pred_final): 8.6f}')
print(f'\nDuration:{time.time() - start_time:.0f} seconds')

y_pred_final=torch.argmax(y_pred, dim=1)
y_pred_final

y_pred_final=y_pred_final.cpu().detach().numpy()

y_pred_final=y_pred_final.reshape(-1,1)

submission=pd.read_csv('sample_submission.csv')

submission['TARGET']=y_pred_final

submission.to_csv('submission_PyTorch.csv', index=False)

from google.colab import files

files.download('submission_PyTorch.csv')